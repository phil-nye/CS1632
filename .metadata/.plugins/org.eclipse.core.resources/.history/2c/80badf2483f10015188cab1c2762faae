import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;

import org.junit.Before;
import org.junit.Test;

public class JavaArraysTests {

	private static final String HashMap = null;
	int intArr[][];
    
    //Generate 100 random int arrays
    private void createArrays() {
        Random rndm = new Random();
        intArr = new int[100][];	//100 int arrays
        int length;
        for(int i = 0; i < 100; i++) {
            length = rndm.nextInt(10000) + 1;    //length should be between 1 and 10,000
            System.out.println("Length: " + length);
            intArr[i] = new int[length];
            for(int j = 0; j < length; j++) {
                intArr[i][j] = rndm.nextInt(100000) + 1;  //generate a random number between 1 and 100,000
            }
        }
        System.out.println("END\n");
    }

    //Setup randomly generated arrays
    @Before
    public void setup() {
        createArrays();
    }
    
    // Test array sort: size before sorting should be the same
    // as the size after sorting
    @Test
    public void sortSizeTest() {
        for(int i = 0; i < intArr.length; i++) {
        	int originalCopy[] = Arrays.copyOf(intArr[i], intArr[i].length);	//create deep copy of original
        	Arrays.sort(intArr[i]);	//sort array
        	
        	assertEquals(originalCopy.length, intArr[i].length);
        }
    }

    // Test array sort: sorting arrays with the same content (e.g. the same copy) should
    // result in the same sorted array
    @Test
    public void sortConsistencyTest() {
    	for(int i = 0; i < intArr.length; i++) {
    		int originalCopy[] = Arrays.copyOf(intArr[i], intArr[i].length);	//create deep copy of original
    		Arrays.sort(intArr[i]);	//sort original array
    		Arrays.sort(originalCopy);	//sort copy array
    		
    		for(int j = 0; j < originalCopy.length; j++) {	//compare elements in original are same position as copy
    			if(intArr[i][j] != originalCopy[j]) {
    				fail("sortSameContentsTest");
    			}
    			else {
    				assertTrue(true);
    			}
    		}
    	}
    }
    
    // Test array sort: there should be the same exact content in the sorted array as the unsorted array
    // (although in a different order)
    @Test
    public void sortSameContentTest() {
    	for(int i = 0; i < intArr.length; i++) {
    		int originalCopy[] = Arrays.copyOf(intArr[i], intArr[i].length);	//create deep copy of original
    		Arrays.sort(intArr[i]);
    		
    		////keys are unique entries; values are total number of occurrences in the array
    		Map<Integer, Integer> originalTM = new TreeMap<Integer, Integer>();
    		Map<Integer, Integer> copyTM = new TreeMap<Integer, Integer>();
    		
    		//setting up tree maps
    		for(int j = 0; j < intArr[i].length; j++) {
    			//generate tree map for copy
    			if(copyTM.containsKey(originalCopy[j])) {	//if key exists
    				copyTM.put(originalCopy[j], copyTM.get(originalCopy[j]) + 1);	//increment value
    			}
    			else {	
    				copyTM.put(originalCopy[j], 1);	//if key does not exit; init to 1
    			}
    			
    			//generate tree map for original
    			if(originalTM.containsKey(intArr[i][j])) {
    				originalTM.put(intArr[i][j], originalTM.get(intArr[i][j]) + 1);	//increment value
    			}
    			else {
    				copyTM.put(intArr[i][j], 1);	//if key does not exit; init to 1
    			}
    		}
    		
    		//compare tree map; the tree map should be the same
    		assertTrue(originalTM.equals(copyTM));
    	}
    }
}
































